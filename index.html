<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plane Mirror — Fixed Mirror, Draggable O & Eye (Canvas Mode)</title>
<style>
  :root{
    --card:#ffffff; --muted:#6b7280; --accent:#f97316; --eye:#2563eb; --green:#10b981; --glass: rgba(15,23,42,0.04);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{display:flex;align-items:center;justify-content:center;background: lightblue;padding:18px;color:#0b1220}
  .app{Width:100%;max-width:1100px;background:var(--card);border-radius:12px;padding:14px;box-shadow:0 10px 40px rgba(12,18,31,0.06)}
  header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
  h1{font-size:18px;margin:0}
  .main{display:flex;gap:12px}
  .canvas-wrap{flex:1;min-width:420px;background:var(--glass);border-radius:8px;padding:10px}
  canvas{width:100%;height:560px;border-radius:6px;background:linear-gradient(180deg,#fbfdff 0%,#f1f7ff 100%);display:block;touch-action:none}
  .panel{width:320px;min-width:260px}
  .controls{background:#fff;border-radius:8px;padding:12px;border:1px solid #eef2ff;box-shadow:0 4px 18px rgba(14,22,50,0.03)}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:linear-gradient(180deg,#2563eb,#1d4ed8);color:white;font-weight:600;border:none;cursor:pointer}
  .btn.ghost{background:transparent;color:var(--muted);border:1px solid #eef2ff}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
  .dot{width:14px;height:14px;border-radius:50%}
  .dot.o{background:var(--accent)}
  .dot.e{background:var(--eye)}
  .dot.img{background:transparent;border:2px dashed var(--green);width:12px;height:12px;border-radius:3px}
  .readouts{margin-top:10px;display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .readout{background:#fbfdff;border-radius:8px;padding:8px;border:1px solid #eef2ff;font-size:13px}
  .toggle{display:flex;gap:6px;align-items:center}
  .muted{color:var(--muted)}
  .footer{margin-top:10px;font-size:13px;color:var(--muted)}
  @media (max-width:980px){ .main{flex-direction:column} .panel{width:100%} canvas{height:420px} }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Plane mirror reflection simulator (fixed mirror)">
    <header>
      <h1>Reflection by a Plane Mirror — Fixed Mirror</h1>
      <div class="muted">Mirror is fixed. Drag only the object (orange) and the eye (blue).</div>
    </header>

    <div class="main">
      <div class="canvas-wrap" aria-hidden="false">
        <canvas id="c" width="900" height="560"></canvas>
      </div>

      <aside class="panel">
        <div class="controls" role="region" aria-label="Controls">
          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <div style="font-weight:600">Controls</div>
            <div style="display:flex;gap:8px">
              <button id="resetBtn" class="btn" title="Reset positions">Reset</button>
              <button id="snapBtn" class="btn ghost" title="Toggle snap">Snap</button>
            </div>
          </div>

          <div style="margin-top:10px">
            <label>Helpers</label>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <div class="toggle"><input id="showNormals" type="checkbox" checked /> <label for="showNormals">Show normal</label></div>
              <div class="toggle"><input id="showAngles" type="checkbox" checked /> <label for="showAngles">Show angles</label></div>
              <div class="toggle"><input id="showDashed" type="checkbox" checked /> <label for="showDashed">Show dashed extensions</label></div>
              <div class="toggle"><input id="animateLight" type="checkbox" /> <label for="animateLight">Animate</label></div>
            </div>
          </div>

          <div class="small" style="margin-top:10px">Interaction: drag the orange (O) or blue (Eye) circles. Mirror is fixed in place (not draggable).</div>

          <div class="legend">
            <div class="legend-item"><span class="dot o"></span> O (object)</div>
            <div class="legend-item"><span class="dot e"></span> Eye</div>
            <div class="legend-item"><span class="dot img"></span> Virtual image</div>
          </div>

          <div class="readouts" aria-live="polite" style="margin-top:12px">
            <div class="readout">Mirror angle: <strong id="mirrorAngle">0°</strong></div>
            <div class="readout">Incidence / Reflection: <strong id="incRef">— / —</strong></div>
            <div class="readout">Hit point (x,y): <strong id="hitPoint">—</strong></div>
            <div class="readout">O to image dist: <strong id="oiDist">—</strong></div>
          </div>

        </div>
        <div class="footer">Tip: double-click canvas to reset. Snap toggles 10px grid snapping for O & Eye.</div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // UI elements
  const mirrorAngleLabel = document.getElementById('mirrorAngle');
  const incRefEl = document.getElementById('incRef');
  const hitPointEl = document.getElementById('hitPoint');
  const oiDistEl = document.getElementById('oiDist');
  const resetBtn = document.getElementById('resetBtn');
  const snapBtn = document.getElementById('snapBtn');
  const showNormals = document.getElementById('showNormals');
  const showAngles = document.getElementById('showAngles');
  const showDashed = document.getElementById('showDashed');
  const animateLight = document.getElementById('animateLight');

  let snap = false;
  snapBtn.addEventListener('click', () => {
    snap = !snap;
    snapBtn.style.opacity = snap ? 1 : 0.9;
    snapBtn.classList.toggle('btn', snap);
    snapBtn.classList.toggle('btn.ghost', !snap);
  });

  // DPR handling
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvas();
  window.addEventListener('resize', () => { fitCanvas(); draw(); });

  // Positions and fixed mirror
  let O = { x: 160, y: 380 };
  let Eye = { x: 720, y: 420 };
  // fixed mirror endpoints (will be set in init)
  let mirrorA = { x: 0, y: 0 };
  let mirrorB = { x: 0, y: 0 };

  function initPositions() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    O = { x: Math.max(90, w*0.18), y: Math.min(h-80, h*0.68) };
    Eye = { x: Math.max(280, w*0.78), y: Math.min(h-60, h*0.75) };
    const midx = w*0.5, midy = h*0.36;
    const L = Math.min(360, w*0.6);
    // fixed horizontal mirror (not draggable)
    mirrorA = { x: midx - L/2, y: midy };
    mirrorB = { x: midx + L/2, y: midy };
  }
  initPositions();

  // util functions
  function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
  function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
  function mul(a,s){return {x:a.x*s,y:a.y*s};}
  function dot(a,b){return a.x*b.x + a.y*b.y;}
  function len(v){return Math.hypot(v.x,v.y);}  
  function norm(v){ const L = len(v)||1; return {x:v.x/L, y:v.y/L}; }
  function perp(v){ return {x:-v.y, y:v.x}; }
  function angleDeg(v){ return Math.atan2(v.y, v.x) * 180/Math.PI; }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function reflectPointAcrossLine(P, A, B){
    const AP = sub(P, A);
    const AB = sub(B, A);
    const ab2 = dot(AB, AB) || 1;
    const t = dot(AP, AB) / ab2;
    const proj = add(A, mul(AB, t));
    const refl = add(proj, mul(sub(proj, P), 1));
    return refl;
  }

  // return intersection point and parameters (u along r, v along s)
  function lineIntersect(P, r, Q, s){
    const rxs = r.x*s.y - r.y*s.x;
    if (Math.abs(rxs) < 1e-7) return null;
    const qp = { x: Q.x - P.x, y: Q.y - P.y };
    const u = (qp.x*s.y - qp.y*s.x) / rxs; // parameter for P + u*r
    const v = (qp.x*r.y - qp.y*r.x) / rxs; // parameter for Q + v*s
    const pt = add(P, mul(r, u));
    return { pt, u, v };
  }

  function reflectVector(v, n){
    const d = 2 * dot(v, n);
    return sub(v, mul(n, d));
  }

  function pointToLineDist(Pt, A, B){
    const AB = sub(B,A);
    const area2 = Math.abs( (AB.x)*(Pt.y - A.y) - (AB.y)*(Pt.x - A.x) );
    const base = len(AB) || 1;
    return area2 / base;
  }

  // compute reflection data (same approach: reflect Eye -> Eye' and intersect O->Eye' with mirror line)
  function computeReflection(){
    const A = mirrorA, B = mirrorB;
    const Eref = reflectPointAcrossLine(Eye, A, B);
    const r = sub(Eref, O);
    const s = sub(B, A);
    const inter = lineIntersect(O, r, A, s);
    if (!inter) return null;
    // require intersection to lie on mirror segment and in front of the object ray
    if (inter.v < 0 || inter.v > 1) return null; // intersection off the finite mirror
    if (inter.u < 0) return null; // intersection lies behind the object along ray direction
    const P = inter.pt;
    const v_in = sub(P, O);
    const v_out = sub(Eye, P);
    const mirrorDir = norm(sub(B,A));
    let normal = perp(mirrorDir);
    // orient normal so it points against the incident vector
    if (dot(normal, v_in) > 0) normal = mul(normal, -1);
    const inDeg = +( Math.acos( clamp(Math.abs(dot(norm(v_in), norm(normal))), 0, 1) ) * 180/Math.PI ).toFixed(2);
    const outDeg = +( Math.acos( clamp(Math.abs(dot(norm(v_out), norm(normal))), 0, 1) ) * 180/Math.PI ).toFixed(2);
    const Oimage = reflectPointAcrossLine(O, A, B);
    const dO = pointToLineDist(O, A, B);
    return { P, v_in, v_out, normal, inDeg, outDeg, Oimage, dO, Eref };
  }

  // drawing
  let animT = 0, animateEnabled = false;
  animateLight.addEventListener('change', () => { animateEnabled = animateLight.checked; if (!animateEnabled) animT = 0; });

  // Eye image: use external image file image.png and auto-rotate the image so the eye looks toward the hit point (P)
  const eyeImg = new Image();
  eyeImg.src = 'image.png'; // place image.png in the repo or public folder
  // optional: enable crossOrigin if you host remote image and need to avoid tainting canvas
  // eyeImg.crossOrigin = 'anonymous';
  let eyeSize = 50; // rendered pixel size of icon (increased per request)

  function draw(){
    fitCanvas();
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);

    // mirror (fixed)
    const A = mirrorA, B = mirrorB;
    const dir = norm(sub(B,A));
    const normal = perp(dir);
    ctx.save();
    ctx.translate((A.x+B.x)/2, (A.y+B.y)/2);
    const angle = Math.atan2(dir.y, dir.x);
    ctx.rotate(angle);
    const halfLen = len(sub(B,A))/2;
    const mirrorW = 10;
    ctx.fillStyle = '#f8fafc';
    ctx.fillRect(-halfLen, -mirrorW/2, halfLen*2, mirrorW);
    ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1;
    for (let x=-halfLen; x < halfLen; x += 18) { ctx.beginPath(); ctx.moveTo(x, -mirrorW/2); ctx.lineTo(x+10, mirrorW/2); ctx.stroke(); }
    ctx.restore();

    // label mirror as fixed
    ctx.fillStyle = '#374151'; ctx.font = '12px Inter, Arial';
    ctx.fillText('Mirror (fixed)', (A.x+B.x)/2 + 8, (A.y+B.y)/2 - 12);
    mirrorAngleLabel.textContent = `${Math.round(angleDeg(dir))}°`;

    // sample rays
    const count = 7;
    for (let i=0;i<count;i++){
      const t = i/(count-1);
      const mp = { x: A.x + (B.x-A.x)*t, y: A.y + (B.y-A.y)*t };
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(30,64,175,0.12)';
      ctx.lineWidth = 1.6;
      ctx.moveTo(O.x, O.y); ctx.lineTo(mp.x, mp.y); ctx.stroke();

      // reflected
      const v_in = sub(mp, O);
      let n = perp(norm(sub(B,A)));
      if (dot(n, v_in) > 0) n = mul(n, -1);
      const v_ref = reflectVector(v_in, n);
      const fwd = add(mp, mul(norm(v_ref), 800));
      ctx.beginPath(); ctx.strokeStyle = 'rgba(99,102,241,0.25)'; ctx.moveTo(mp.x, mp.y); ctx.lineTo(fwd.x, fwd.y); ctx.stroke();

      if (showDashed.checked) {
        const back = sub(mp, mul(norm(v_ref), 300));
        ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle='rgba(99,102,241,0.18)'; ctx.beginPath(); ctx.moveTo(mp.x, mp.y); ctx.lineTo(back.x, back.y); ctx.stroke(); ctx.restore();
      }
    }

    const res = computeReflection();
    if (res) {
      const P = res.P;
      // incident highlighted
      ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(249,115,22,0.98)'; ctx.moveTo(O.x, O.y); ctx.lineTo(P.x, P.y); ctx.stroke();
      // reflected to eye
      ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(37,99,235,0.98)'; ctx.moveTo(P.x, P.y); ctx.lineTo(Eye.x, Eye.y); ctx.stroke();

      // animate pulse if enabled
      if (animateEnabled) {
        animT = (animT + 0.02) % 1;
        if (animT < 0.5) {
          const tt = animT/0.5;
          const px = O.x + (P.x - O.x)*tt;
          const py = O.y + (P.y - O.y)*tt;
          ctx.beginPath(); ctx.fillStyle = '#f97316'; ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
        } else {
          const tt = (animT-0.5)/0.5;
          const px = P.x + (Eye.x - P.x)*tt;
          const py = P.y + (Eye.y - P.y)*tt;
          ctx.beginPath(); ctx.fillStyle = '#2563eb'; ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
        }
        requestAnimationFrame(draw);
      } else { animT = 0; }

      // hit point marker
      ctx.beginPath(); ctx.fillStyle = '#111827'; ctx.arc(P.x, P.y, 3.8, 0, Math.PI*2); ctx.fill();

      // normals toggle
      if (showNormals.checked) {
        const nunit = norm(res.normal);
        const N1 = add(P, mul(nunit, -50));
        const N2 = add(P, mul(nunit, 50));
        ctx.beginPath(); ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 1.4; ctx.moveTo(N1.x, N1.y); ctx.lineTo(N2.x, N2.y); ctx.stroke();
      }

      // angle arcs toggle
      if (showAngles.checked) {
        const mirrorDir = norm(sub(B,A));
        const tangentAngle = Math.atan2(mirrorDir.y, mirrorDir.x);
        const incidentAngle = Math.atan2(res.v_in.y, res.v_in.x);
        const reflectedAngle = Math.atan2(res.v_out.y, res.v_out.x);
        const normalAngle = Math.atan2(res.normal.y, res.normal.x);
        const arcR = 34;

        ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(249,115,22,0.92)';
        ctx.arc(P.x, P.y, arcR, normalAngle, incidentAngle, false); ctx.stroke();

        ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(37,99,235,0.92)';
        ctx.arc(P.x, P.y, arcR+6, normalAngle, reflectedAngle, false); ctx.stroke();

        ctx.font = '12px Inter, Arial'; ctx.fillStyle = '#111827';
        ctx.fillText(`${res.inDeg}°`, P.x + Math.cos((normalAngle+incidentAngle)/2)*(arcR-8), P.y + Math.sin((normalAngle+incidentAngle)/2)*(arcR-8));
        ctx.fillText(`${res.outDeg}°`, P.x + Math.cos((normalAngle+reflectedAngle)/2)*(arcR+10), P.y + Math.sin((normalAngle+reflectedAngle)/2)*(arcR+10));
      }

      // virtual image
      if (res.Oimage) {
        ctx.fillStyle = 'rgba(16,185,129,0.95)';
        ctx.fillRect(res.Oimage.x-5, res.Oimage.y-5, 10, 10);
        ctx.font = '12px Inter, Arial'; ctx.fillStyle = '#065f46'; ctx.fillText("O'", res.Oimage.x + 8, res.Oimage.y + 4);
      }

      // readouts
      incRefEl.textContent = `${res.inDeg}° / ${res.outDeg}°`;
      hitPointEl.textContent = `${Math.round(P.x)}, ${Math.round(P.y)}`;
      oiDistEl.textContent = `${res.dO.toFixed(1)} px (perp)`;
    } else {
      incRefEl.textContent = '— / —';
      hitPointEl.textContent = '—';
      oiDistEl.textContent = '—';
    }

    // draw O
    ctx.beginPath(); ctx.fillStyle='#f97316'; ctx.strokeStyle='#00000022'; ctx.lineWidth=1.2; ctx.arc(O.x,O.y,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#000'; ctx.font='13px Inter, Arial'; ctx.fillText('O', O.x+14, O.y+5);

    // draw Eye as image icon (rotate so the eye looks toward the hit point when available)
    if (eyeImg && eyeImg.complete) {
      const iw = eyeSize, ih = eyeSize;
      // determine orientation: prefer hit point P when available, else face toward mirror center
      let angleTo = 0;
      if (res && res.P) {
        angleTo = Math.atan2(res.P.y - Eye.y, res.P.x - Eye.x);
      } else {
        // fallback: look toward mirror center
        const mid = { x: (mirrorA.x + mirrorB.x)/2, y: (mirrorA.y + mirrorB.y)/2 };
        angleTo = Math.atan2(mid.y - Eye.y, mid.x - Eye.x);
      }
      // Fix: image was facing the opposite direction — add PI to flip orientation
      angleTo += Math.PI;

      ctx.save();
      ctx.translate(Eye.x, Eye.y);
      ctx.rotate(angleTo);
      ctx.drawImage(eyeImg, -iw/2, -ih/2, iw, ih);
      ctx.restore();
      // subtle stroke for clarity
      ctx.beginPath(); ctx.strokeStyle = '#00000022'; ctx.lineWidth = 1; ctx.ellipse(Eye.x, Eye.y, iw/2, ih/2, 0, 0, Math.PI*2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.fillStyle='#2563eb'; ctx.strokeStyle='#00000022'; ctx.arc(Eye.x,Eye.y,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#000'; ctx.font='13px Inter, Arial'; ctx.fillText('Eye', Eye.x+14, Eye.y+5);
    }
  }

  // pointer dragging (only O and Eye)
  function getPos(evt){
    const r = canvas.getBoundingClientRect();
    return { x: evt.clientX - r.left, y: evt.clientY - r.top };
  }
  function hitTest(pt, target, radius){
    return ((pt.x-target.x)*(pt.x-target.x)+(pt.y-target.y)*(pt.y-target.y)) <= (radius*radius);
  }

  let dragging = null, dragId = null;
  canvas.addEventListener('pointerdown', (e) => {
    const p = getPos(e);
    // adapt hit radius to eye icon size
    const eyeRadius = Math.max(12, eyeSize/2);
    if (hitTest(p, O, 14)){ dragging = 'O'; dragId = e.pointerId; canvas.setPointerCapture(dragId); return; }
    if (hitTest(p, Eye, eyeRadius)){ dragging = 'Eye'; dragId = e.pointerId; canvas.setPointerCapture(dragId); return; }
    dragging = null;
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const p = getPos(e);
    if (dragging === 'O') {
      O.x = clamp(p.x, 12, canvas.clientWidth-12);
      O.y = clamp(p.y, 12, canvas.clientHeight-12);
      if (snap) { O.x = Math.round(O.x/10)*10; O.y = Math.round(O.y/10)*10; }
    } else if (dragging === 'Eye') {
      Eye.x = clamp(p.x, 12, canvas.clientWidth-12);
      Eye.y = clamp(p.y, 12, canvas.clientHeight-12);
      if (snap) { Eye.x = Math.round(Eye.x/10)*10; Eye.y = Math.round(Eye.y/10)*10; }
    }
    draw();
  });

  canvas.addEventListener('pointerup', (e) => { if (dragId === e.pointerId) { try{ canvas.releasePointerCapture(dragId); } catch{} } dragging = null; dragId = null; });

  // reset / double-click
  function reset(){ initPositions(); animateLight.checked = false; animateEnabled = false; animT = 0; draw(); }
  resetBtn.addEventListener('click', reset);
  canvas.addEventListener('dblclick', reset);

  // keyboard shortcuts (when canvas focused)
  window.addEventListener('keydown', (e) => {
    if (document.activeElement !== document.body && document.activeElement !== canvas) return;
    const step = e.shiftKey ? 10 : 4;
    if (e.key === 'ArrowLeft'){ O.x -= step; Eye.x -= step; draw(); }
    if (e.key === 'ArrowRight'){ O.x += step; Eye.x += step; draw(); }
    if (e.key === 'r'){ reset(); draw(); }
  });

  // redraw once image loads
  eyeImg.onload = () => { draw(); };

  // initial render
  draw();
})();
</script>
</body>
</html>
