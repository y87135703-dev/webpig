<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plane Mirror — Fixed Mirror, Draggable O & Eye (Canvas Mode)</title>
<style>
  :root{
    --card:#ffffff; --muted:#6b7280; --accent:#f97316; --eye:#2563eb; --green:#10b981; --glass: rgba(15,23,42,0.04);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#e6eefc 0%,#f8fafc 100%);padding:18px;color:#0b1220}
  .app{width:100%;max-width:1100px;background:var(--card);border-radius:12px;padding:14px;box-shadow:0 10px 40px rgba(12,18,31,0.06)}
  header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
  h1{font-size:18px;margin:0}
  .main{display:flex;gap:12px}
  .canvas-wrap{flex:1;min-width:420px;background:var(--glass);border-radius:8px;padding:10px}
  canvas{width:100%;height:560px;border-radius:6px;background:linear-gradient(180deg,#fbfdff 0%,#f1f7ff 100%);display:block;touch-action:none}
  .panel{width:320px;min-width:260px}
  .controls{background:#fff;border-radius:8px;padding:12px;border:1px solid #eef2ff;box-shadow:0 4px 18px rgba(14,22,50,0.03)}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:linear-gradient(180deg,#2563eb,#1d4ed8);color:white;font-weight:600;border:none;cursor:pointer}
  .btn.ghost{background:transparent;color:var(--muted);border:1px solid #eef2ff}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
  .dot{width:14px;height:14px;border-radius:50%}
  .dot.o{background:var(--accent)}
  .dot.e{background:var(--eye)}
  .dot.img{background:transparent;border:2px dashed var(--green);width:12px;height:12px;border-radius:3px}
  .readouts{margin-top:10px;display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .readout{background:#fbfdff;border-radius:8px;padding:8px;border:1px solid #eef2ff;font-size:13px}
  .toggle{display:flex;gap:6px;align-items:center}
  .muted{color:var(--muted)}
  .footer{margin-top:10px;font-size:13px;color:var(--muted)}
  @media (max-width:980px){ .main{flex-direction:column} .panel{width:100%} canvas{height:420px} }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Plane mirror reflection simulator (fixed mirror)">
    <header>
      <h1>Reflection by a Plane Mirror — Fixed Mirror</h1>
      <div class="muted">Mirror is fixed. Drag only the object (orange) and the eye (blue).</div>
    </header>

    <div class="main">
      <div class="canvas-wrap" aria-hidden="false">
        <canvas id="c" width="900" height="560"></canvas>
      </div>

      <aside class="panel">
        <div class="controls" role="region" aria-label="Controls">
          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <div style="font-weight:600">Controls</div>
            <div style="display:flex;gap:8px">
              <button id="resetBtn" class="btn" title="Reset positions">Reset</button>
              <button id="snapBtn" class="btn ghost" title="Toggle snap">Snap</button>
            </div>
          </div>

          <div style="margin-top:10px">
            <label>Helpers</label>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <div class="toggle"><input id="showNormals" type="checkbox" checked /> <label for="showNormals">Show normal</label></div>
              <div class="toggle"><input id="showAngles" type="checkbox" checked /> <label for="showAngles">Show angles</label></div>
              <div class="toggle"><input id="showDashed" type="checkbox" checked /> <label for="showDashed">Show dashed extensions</label></div>
              <div class="toggle"><input id="animateLight" type="checkbox" /> <label for="animateLight">Animate</label></div>
            </div>
          </div>

          <div class="small" style="margin-top:10px">Interaction: drag the orange (O) or blue (Eye) circles. Mirror is fixed in place (not draggable).</div>

          <div class="legend">
            <div class="legend-item"><span class="dot o"></span> O (object)</div>
            <div class="legend-item"><span class="dot e"></span> Eye</div>
            <div class="legend-item"><span class="dot img"></span> Virtual image</div>
          </div>

          <div class="readouts" aria-live="polite" style="margin-top:12px">
            <div class="readout">Mirror angle: <strong id="mirrorAngle">0°</strong></div>
            <div class="readout">Incidence / Reflection: <strong id="incRef">— / —</strong></div>
            <div class="readout">Hit point (x,y): <strong id="hitPoint">—</strong></div>
            <div class="readout">O to image dist: <strong id="oiDist">—</strong></div>
          </div>

        </div>
        <div class="footer">Tip: double-click canvas to reset. Snap toggles 10px grid snapping for O & Eye.</div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // UI elements
  const mirrorAngleLabel = document.getElementById('mirrorAngle');
  const incRefEl = document.getElementById('incRef');
  const hitPointEl = document.getElementById('hitPoint');
  const oiDistEl = document.getElementById('oiDist');
  const resetBtn = document.getElementById('resetBtn');
  const snapBtn = document.getElementById('snapBtn');
  const showNormals = document.getElementById('showNormals');
  const showAngles = document.getElementById('showAngles');
  const showDashed = document.getElementById('showDashed');
  const animateLight = document.getElementById('animateLight');

  let snap = false;
  snapBtn.addEventListener('click', () => {
    snap = !snap;
    snapBtn.style.opacity = snap ? 1 : 0.9;
    snapBtn.classList.toggle('btn', snap);
    snapBtn.classList.toggle('btn.ghost', !snap);
  });

  // DPR handling
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvas();
  window.addEventListener('resize', () => { fitCanvas(); draw(); });

  // Positions and fixed mirror
  let O = { x: 160, y: 380 };
  let Eye = { x: 720, y: 420 };
  // fixed mirror endpoints (will be set in init)
  let mirrorA = { x: 0, y: 0 };
  let mirrorB = { x: 0, y: 0 };

  function initPositions() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    O = { x: Math.max(90, w*0.18), y: Math.min(h-80, h*0.68) };
    Eye = { x: Math.max(280, w*0.78), y: Math.min(h-60, h*0.75) };
    const midx = w*0.5, midy = h*0.36;
    const L = Math.min(360, w*0.6);
    // fixed horizontal mirror (not draggable)
    mirrorA = { x: midx - L/2, y: midy };
    mirrorB = { x: midx + L/2, y: midy };
  }
  initPositions();

  // util functions
  function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
  function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
  function mul(a,s){return {x:a.x*s,y:a.y*s};}
  function dot(a,b){return a.x*b.x + a.y*b.y;}
  function len(v){return Math.hypot(v.x,v.y);}  
  function norm(v){ const L = len(v)||1; return {x:v.x/L, y:v.y/L}; }
  function perp(v){ return {x:-v.y, y:v.x}; }
  function angleDeg(v){ return Math.atan2(v.y, v.x) * 180/Math.PI; }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function reflectPointAcrossLine(P, A, B){
    const AP = sub(P, A);
    const AB = sub(B, A);
    const ab2 = dot(AB, AB) || 1;
    const t = dot(AP, AB) / ab2;
    const proj = add(A, mul(AB, t));
    const refl = add(proj, mul(sub(proj, P), 1));
    return refl;
  }

  // return intersection point and parameters (u along r, v along s)
  function lineIntersect(P, r, Q, s){
    const rxs = r.x*s.y - r.y*s.x;
    if (Math.abs(rxs) < 1e-7) return null;
    const qp = { x: Q.x - P.x, y: Q.y - P.y };
    const u = (qp.x*s.y - qp.y*s.x) / rxs; // parameter for P + u*r
    const v = (qp.x*r.y - qp.y*r.x) / rxs; // parameter for Q + v*s
    const pt = add(P, mul(r, u));
    return { pt, u, v };
  }

  function reflectVector(v, n){
    const d = 2 * dot(v, n);
    return sub(v, mul(n, d));
  }

  function pointToLineDist(Pt, A, B){
    const AB = sub(B,A);
    const area2 = Math.abs( (AB.x)*(Pt.y - A.y) - (AB.y)*(Pt.x - A.x) );
    const base = len(AB) || 1;
    return area2 / base;
  }

  // compute reflection data (same approach: reflect Eye -> Eye' and intersect O->Eye' with mirror line)
  function computeReflection(){
    const A =
